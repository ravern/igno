use std::{iter, process, string::FromUtf8Error};

use clap::Parser;
use futures::future::join_all;
use hyper::{
  client::{connect::HttpConnector, Client},
  http::{uri::InvalidUri, StatusCode},
};
use hyper_tls::HttpsConnector;
use thiserror::Error;

#[derive(Debug, Parser)]
#[clap(author = "Ravern Koh <ravernkoh@gmail.com>")]
#[clap(version = "0.1.0")]
#[clap(about = "Generate gitignore files with ease")]
enum Command {
  /// Generate gitignore for given environments
  Generate {
    /// Environments to generate gitignore for
    environments: Vec<String>,
  },

  /// Search through available platforms
  Search {
    /// Keyword to use when searching
    query: String,
  },
}

#[derive(Debug, Error)]
enum Error {
  #[error("{}", 0)]
  InvalidUri(#[from] InvalidUri),
  #[error("{}", 0)]
  Utf8(#[from] FromUtf8Error),
  #[error("{}", 0)]
  Hyper(#[from] hyper::Error),
  #[error("failed to fetch gitignore for {}: {}", _0, _1)]
  Http(String, String),
}

#[tokio::main]
async fn main() {
  let connector = HttpsConnector::new();
  let client = Client::builder().build(connector);

  if let Err(error) = run(&client).await {
    eprintln!("Error: {}", error);
    process::exit(1);
  }
}

async fn run(
  client: &Client<HttpsConnector<HttpConnector>>,
) -> Result<(), Error> {
  match Command::parse() {
    Command::Generate { environments } => {
      run_generate(client, environments).await
    }
    Command::Search { query } => run_search(client, query).await,
  }
}

async fn run_generate(
  client: &Client<HttpsConnector<HttpConnector>>,
  environments: Vec<String>,
) -> Result<(), Error> {
  let gitignores = environments
    .into_iter()
    .map(|environment| fetch_gitignore(&client, environment));

  let gitignores = join_all(gitignores)
    .await
    .into_iter()
    .collect::<Result<Vec<(String, String)>, Error>>()?;

  println!("##################################");
  println!("### Generated by ignore v0.1.0 ###");
  println!("##################################");

  for (environment, content) in gitignores {
    let padding = iter::repeat("#")
      .take(environment.len())
      .collect::<String>();
    println!("");
    println!("####{}####", &padding);
    println!("### {} ###", environment);
    println!("####{}####", &padding);
    println!("");
    println!("{}", content);
  }

  println!("###############");
  println!("### The end ###");
  println!("###############");

  Ok(())
}

async fn run_search(
  _client: &Client<HttpsConnector<HttpConnector>>,
  _query: String,
) -> Result<(), Error> {
  Ok(())
}

async fn fetch_gitignore(
  client: &Client<HttpsConnector<HttpConnector>>,
  environment: String,
) -> Result<(String, String), Error> {
  let uri = format!(
    "https://raw.githubusercontent.com/toptal/gitignore/master/templates/{}.gitignore",
    &environment
  )
  .parse()?;

  let resp = client.get(uri).await?;
  let status = resp.status();

  let bytes = hyper::body::to_bytes(resp.into_body()).await?;
  let content = String::from_utf8(bytes.to_vec())?;

  if status == StatusCode::OK {
    Ok((environment, content))
  } else {
    Err(Error::Http(environment, content))
  }
}
